<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Mariana Montes" />

<meta name="date" content="2024-05-19" />

<title>Using dataframes</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<style type="text/css">.gloss--glossed:after {clear: left;content: '';display: block;}ul.gloss--glossed,ol.gloss--glossed {padding-left: 0;}ul.gloss--glossed li,ol.gloss--glossed li {list-style-type: none;}.gloss__abbr {font-variant: small-caps;font-variant-numeric: oldstyle-nums;text-transform: lowercase;}.gloss__word {float: left;margin-bottom: 1em;margin-right: 1em;}.gloss__word p {margin: 0;}.gloss--no-space .gloss__word {margin-right: 0;}.gloss--no-space .gloss__word.gloss__word--spacer {margin-right: 1.5em;}.gloss__words:first-child,.gloss--glossed li:first-child {margin-top: 1em;}.gloss--glossed li:last-child {margin-bottom: 1em;}.gloss__line--original {margin-bottom: 1em;}.gloss__line--free,.gloss__line--no-align {clear: left;}.gloss__line--hidden {display: none;}</style>
<script>/*! leipzig.js v0.8.0 | ISC License | github.com/bdchauvette/leipzig.js */
(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define('Leipzig', ['exports', 'module'], factory);
  } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
    factory(exports, module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, mod);
    global.Leipzig = mod.exports;
  }
})(this, function (exports, module) {
  'use strict';

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
  Adds a class to an element
  @private
  @param {Element} el - element to add the class to
  @param {String} className - class name to add
  */
  function addClass(el, className) {
    if (el.classList) {
      el.classList.add(className);
    } else {
      el.className += ' ' + className;
    }
  }

  /**
  Checks if an element has a given class
  @private
  @param {Element} el - element to search for the class
  @param {String} className - class name to search for
  */
  function hasClass(el, className) {
    var test;

    if (el.classList) {
      test = el.classList.contains(className);
    } else {
      var className = new RegExp('(^| )' + className + '( |$)', 'gi');
      test = new RegExp(className).test(el.className);
    }

    return test;
  }

  /**
  Helper function for creating custom events
  @private
  */
  function LeipzigEvent(name, data) {
    var leipzigEvent = undefined;

    if (window.CustomEvent) {
      leipzigEvent = new CustomEvent(name, {
        detail: data,
        bubbles: true,
        cancelable: true
      });
    } else {
      // For Internet Explorer & PhantomJS
      leipzigEvent = document.createEvent('CustomEvent');
      leipzigEvent.initCustomEvent(name, true, true, data);
    }

    return leipzigEvent;
  }

  /**
  Helper function for triggering custom events
  @private
  */
  function triggerEvent(el, name, data) {
    var e = new LeipzigEvent(name, data);
    el.dispatchEvent(e);
  }

  /**
  Helper function for cloning an object
  @private
  */
  function clone(obj) {
    return _extends({}, obj);
  }

  /**
  Default abbreviations used by the auto tagger
  @private
  */
  var abbreviations = {
    1: 'first person',
    2: 'second person',
    3: 'third person',
    A: 'agent-like argument of canonical transitive verb',
    ABL: 'ablative',
    ABS: 'absolutive',
    ACC: 'accusative',
    ADJ: 'adjective',
    ADV: 'adverb(ial)',
    AGR: 'agreement',
    ALL: 'allative',
    ANTIP: 'antipassive',
    APPL: 'applicative',
    ART: 'article',
    AUX: 'auxiliary',
    BEN: 'benefactive',
    CAUS: 'causative',
    CLF: 'classifier',
    COM: 'comitative',
    COMP: 'complementizer',
    COMPL: 'completive',
    COND: 'conditional',
    COP: 'copula',
    CVB: 'converb',
    DAT: 'dative',
    DECL: 'declarative',
    DEF: 'definite',
    DEM: 'demonstrative',
    DET: 'determiner',
    DIST: 'distal',
    DISTR: 'distributive',
    DU: 'dual',
    DUR: 'durative',
    ERG: 'ergative',
    EXCL: 'exclusive',
    F: 'feminine',
    FOC: 'focus',
    FUT: 'future',
    GEN: 'genitive',
    IMP: 'imperative',
    INCL: 'inclusive',
    IND: 'indicative',
    INDF: 'indefinite',
    INF: 'infinitive',
    INS: 'instrumental',
    INTR: 'intransitive',
    IPFV: 'imperfective',
    IRR: 'irrealis',
    LOC: 'locative',
    M: 'masculine',
    N: 'neuter',
    NEG: 'negation / negative',
    NMLZ: 'nominalizer / nominalization',
    NOM: 'nominative',
    OBJ: 'object',
    OBL: 'oblique',
    P: 'patient-like argument of canonical transitive verb',
    PASS: 'passive',
    PFV: 'perfective',
    PL: 'plural',
    POSS: 'possessive',
    PRED: 'predicative',
    PRF: 'perfect',
    PRS: 'present',
    PROG: 'progressive',
    PROH: 'prohibitive',
    PROX: 'proximal / proximate',
    PST: 'past',
    PTCP: 'participle',
    PURP: 'purposive',
    Q: 'question particle / marker',
    QUOT: 'quotative',
    RECP: 'reciprocal',
    REFL: 'reflexive',
    REL: 'relative',
    RES: 'resultative',
    S: 'single argument of canonical intransitive verb',
    SBJ: 'subject',
    SBJV: 'subjunctive',
    SG: 'singular',
    TOP: 'topic',
    TR: 'transitive',
    VOC: 'vocative'
  };

  /**
  Creates a Leipzig.js glossing object
  @constructor
  @param {String|NodeList|Element} selector - determines elements to be glossed
  @param {Object} config - configuration object
  */
  var Leipzig = function Leipzig(selector) {
    var config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    if (!(this instanceof Leipzig)) {
      return new Leipzig(selector, config);
    }

    if (typeof selector !== 'undefined') {
      if (typeof selector === 'string' || selector instanceof NodeList || selector instanceof Element) {
        config.selector = selector;
      } else if (typeof selector === 'object') {
        // if the first argument is an object, let's assume it's actually a
        // configuration object, and not the selector
        config = selector;
      } else {
        throw new Error('Invalid selector');
      }
    }

    this.config(config);
  };

  /**
  Configures the Leipzig instance
  @param {Object} options - the options
  */
  Leipzig.prototype.config = function (options) {
    var config = {
      selector: '[data-gloss]',
      lastLineFree: true,
      firstLineOrig: false,
      spacing: true,
      autoTag: true,
      async: false,
      lexer: /{(.*?)}|([^\s]+)/g,
      events: {
        beforeGloss: 'gloss:beforeGloss',
        afterGloss: 'gloss:afterGloss',
        beforeLex: 'gloss:beforeLex',
        afterLex: 'gloss:afterLex',
        beforeAlign: 'gloss:beforeAlign',
        afterAlign: 'gloss:afterAlign',
        beforeFormat: 'gloss:beforeFormat',
        afterFormat: 'gloss:afterFormat',
        start: 'gloss:start',
        complete: 'gloss:complete'
      },
      classes: {
        glossed: 'gloss--glossed',
        noSpace: 'gloss--no-space',
        words: 'gloss__words',
        word: 'gloss__word',
        spacer: 'gloss__word--spacer',
        abbr: 'gloss__abbr',
        line: 'gloss__line',
        lineNum: 'gloss__line--',
        original: 'gloss__line--original',
        freeTranslation: 'gloss__line--free',
        noAlign: 'gloss__line--no-align',
        hidden: 'gloss__line--hidden'
      },
      abbreviations: abbreviations
    };

    _extends(config, options);

    // selector should be a string, NodeList or an array of Elements.
    // We'll actually select the elements later, to avoid possible differences
    // in the DOM between construction and glossing
    if (typeof config.selector !== 'string' && !(config.selector instanceof NodeList) && !(config.selector instanceof Element)) {
      throw new Error('Invalid selector');
    }

    // construct the lexer RegExp now, so that we don't have to create it each
    // time the lexer runs
    if (!(config.lexer instanceof RegExp)) {
      if (typeof config.lexer === 'string') {
        config.lexer = new RegExp(config.lexer, 'g');
      } else if (config.lexer instanceof Array) {
        var lexer = config.lexer.join('|');
        config.lexer = new RegExp(lexer, 'g');
      } else {
        throw new Error('Invalid lexer');
      }
    }

    _extends(this, config);
  };

  /**
  Adds abbreviations
  @param {Object} abbreviations - the abbreviations to add
  */
  Leipzig.prototype.addAbbreviations = function (abbreviations) {
    if (typeof abbreviations === 'object') {
      _extends(this.abbreviations, abbreviations);
    } else {
      throw new Error('Invalid abbreviations');
    }
  };

  /**
  Sets abbreviations, overriding existing ones
  @param {Object} abbreviations - the abbreviation definitions
  */
  Leipzig.prototype.setAbbreviations = function (abbreviations) {
    if (typeof abbreviations === 'object') {
      this.abbreviations = abbreviations;
    } else {
      throw new Error('Invalid abbreviations');
    }
  };

  /**
  Extracts word tokens from a gloss line
  @private
  @param {Element} line - the phrase to be lexed
  @returns {Array} The tokens
  */
  Leipzig.prototype.lex = function lex(line) {
    var lexer = this.lexer;

    var tokens = line.match(lexer).map(function (token) {
      // remove braces from groups
      var firstChar = token[0];
      var lastChar = token[token.length - 1];

      if (firstChar === '{' && lastChar === '}') {
        var contents = /(?:{)(.*)(?:})/;
        token = contents.exec(token)[1];
      }

      return token;
    });

    return tokens;
  };

  /**
  Add HTML abbreviation markup to a word
  @private
  @param {String} word - the word to be tagged
  @returns {String} html-tagged word
  */
  Leipzig.prototype.tag = function tag(word) {
    var classes = this.classes;
    var abbreviations = this.abbreviations;

    // (\b[0-4])(?=[A-Z]|\b) : Person & Number
    // (N?[A-Z]+\b)          : Morphemes
    var tagger = /(\b[0-4])(?=[A-Z]|\b)|(N?[A-Z]+\b)/g;
    var tags = word.replace(tagger, function (tag) {
      var maybeNegative = tag[0] === 'N' && tag.length > 1;
      var negStem = maybeNegative ? tag.slice(1) : tag;

      var tagged = undefined;
      var definition = undefined;

      if (abbreviations[tag]) {
        definition = abbreviations[tag];
        tagged = '<abbr class="' + classes.abbr + '" title="' + definition + '">' + tag + '</abbr>';
      } else if (maybeNegative && abbreviations[negStem]) {
        definition = abbreviations[negStem];
        tagged = '<abbr class="' + classes.abbr + '" title="non-' + definition + '">' + tag + '</abbr>';
      } else {
        tagged = '<abbr class="' + classes.abbr + '">' + tag + '</abbr>';
      }

      return tagged;
    });

    return tags;
  };

  /**
  Aligns morphemes on different lines
  @private
  @param {Array} lines - Array of strings to be aligned
  @returns {Array} Array of arrays containing aligned words
  */
  Leipzig.prototype.align = function align(lines) {
    var longestLine = lines.reduce(function (a, b) {
      return a.length > b.length ? a : b;
    }, []);

    return longestLine.map(function (_, i) {
      return lines.map(function (line) {
        return typeof line[i] === 'undefined' ? '' : line[i];
      });
    });
  };

  /**
  Creates an Element containing the aligned glosses
  @private
  @param {Array<Array<String>>} lines - lines to be formatted
  @returns {Element} html element containing the glosses
  */
  Leipzig.prototype.format = function format(groups, wrapperType, lineNumStart) {
    var _this = this;

    var tag = this.tag;

    var spacing = this.spacing;
    var autoTag = this.autoTag;
    var classes = this.classes;
    var wrapper = document.createElement(wrapperType);
    var innerHtml = [];

    addClass(wrapper, classes.words);

    groups.forEach(function (group) {
      var groupLines = [];
      var isEmpty = true;

      group.forEach(function (line, lineNumOffset) {
        var lineNum = lineNumStart + lineNumOffset;
        var lineClasses = [classes.line, classes.lineNum + lineNum];

        if (line.length) {
          isEmpty = false;
        }

        if (lineNumOffset > 0 && autoTag) {
          line = _this.tag(line);
        }

        groupLines.push('<p class="' + lineClasses.join(' ') + '">' + line + '</p>');
      });

      var wordClasses = classes.word;
      if (isEmpty && !spacing) {
        wordClasses += ' ' + classes.spacer;
      }

      innerHtml.push('<div class="' + wordClasses + '">', groupLines.join(''), '</div>');
    });

    wrapper.innerHTML = innerHtml.join('');

    return wrapper;
  };

  /**
  Runs the glosser
  */
  Leipzig.prototype.gloss = function gloss(callback) {
    var _this2 = this;

    var selector = this.selector;
    var classes = this.classes;
    var events = this.events;
    var firstLineOrig = this.firstLineOrig;
    var lastLineFree = this.lastLineFree;
    var spacing = this.spacing;
    var async = this.async;

    /** Processes an individual gloss element */
    var processGloss = function processGloss(gloss, callback) {
      if (!(gloss instanceof Element)) {
        var err = new Error('Invalid gloss element');

        if (typeof callback === 'function') {
          callback(err);
        } else {
          throw err;
        }
      }

      var lines = Array.prototype.slice.call(gloss.children);
      var linesToAlign = [];
      var firstRawLine = null;
      var firstRawLineNum = 0;

      triggerEvent(gloss, events.beforeGloss);

      if (firstLineOrig) {
        var firstLine = lines[0];
        addClass(firstLine, classes.original);
      }

      if (lastLineFree) {
        var lastLine = lines[lines.length - 1];
        addClass(lastLine, classes.freeTranslation);
      }

      // process each line in the gloss
      lines.forEach(function (line, lineNum) {
        // don't align lines that are free translations or original,
        // unformatted lines
        var isOrig = hasClass(line, classes.original);
        var isFree = hasClass(line, classes.freeTranslation);
        var shouldSkip = hasClass(line, classes.noAlign);

        var shouldAlign = !isOrig && !isFree && !shouldSkip;

        if (shouldAlign) {
          triggerEvent(line, events.beforeLex, { lineNum: lineNum });
          var tokens = _this2.lex(line.innerHTML);
          triggerEvent(line, events.afterLex, {
            tokens: tokens,
            lineNum: lineNum
          });

          linesToAlign.push(tokens);
          addClass(line, classes.hidden);

          // if this is the first aligned line, mark the location
          // so that the final aligned glosses can be inserted here
          if (!firstRawLine) {
            firstRawLine = line;
            firstRawLineNum = lineNum;
          }
        } else {
          addClass(line, classes.line);
          addClass(line, classes.lineNum + lineNum);
        }
      });

      var lastRawLineNum = firstRawLineNum + (linesToAlign.length - 1);

      triggerEvent(gloss, events.beforeAlign, {
        lines: linesToAlign,
        firstLineNum: firstRawLineNum,
        lastLineNum: lastRawLineNum
      });

      var alignedLines = _this2.align(linesToAlign);

      triggerEvent(gloss, events.afterAlign, {
        lines: alignedLines,
        firstLineNum: firstRawLineNum,
        lastLineNum: lastRawLineNum
      });

      // determine which type of element the aligned glosses should be wrapped in
      var alignedWrapper = undefined;
      if (gloss.tagName === 'UL' || gloss.tagName === 'OL') {
        alignedWrapper = 'li';
      } else {
        alignedWrapper = 'div';
      }

      triggerEvent(gloss, events.beforeFormat, {
        lines: alignedLines,
        firstLineNum: firstRawLineNum,
        lastLineNum: lastRawLineNum
      });

      var formattedLines = _this2.format(alignedLines, alignedWrapper, firstRawLineNum);
      gloss.insertBefore(formattedLines, firstRawLine);

      triggerEvent(formattedLines, events.afterFormat, {
        firstLineNum: firstRawLineNum,
        lastLineNum: lastRawLineNum
      });

      // finish up by adding relevant classes to the main container
      if (!spacing) {
        addClass(gloss, classes.noSpace);
      }

      addClass(gloss, classes.glossed);

      triggerEvent(gloss, events.afterGloss);
    };

    var glossElements = undefined;
    if (selector instanceof NodeList) {
      glossElements = selector;
    } else if (typeof selector === 'string') {
      glossElements = document.querySelectorAll(selector);
    } else if (selector instanceof Element) {
      // create an array so we can loop later on
      glossElements = [selector];
    } else {
      var err = new Error('Invalid selector');

      if (typeof callback === 'function') {
        callback(err);
      } else {
        throw err;
      }
    }

    triggerEvent(document, events.start, { glosses: glossElements });

    // process each gloss
    var glosses = Array.prototype.slice.call(glossElements);

    var _loop = function (i) {
      var gloss = glosses[i];

      if (async) {
        window.setTimeout(function () {
          return processGloss(gloss, callback);
        });
      } else {
        processGloss(gloss, callback);
      }
    };

    for (var i = 0; i < glosses.length; i++) {
      _loop(i);
    }

    window.setTimeout(function () {
      if (typeof callback === 'function') {
        callback(null, glossElements);
      }

      triggerEvent(document, events.complete, { glosses: glossElements });
    });
  };

  module.exports = Leipzig;
});</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Using dataframes</h1>
<h4 class="author">Mariana Montes</h4>
<h4 class="date">2024-05-19</h4>



<p>The glossr package encourages you to keep your examples in one
dataframe that you can extract glosses from. You can filter it based on
the label names or any other variables and print a series of glosses
next to each other with one call.</p>
<p>If you like this feature and you have, for example, a dataframe
called <code>glosses</code>, you might find yourself calling variations
of <code>gloss_df(filter(glosses, &quot;my-label&quot;))</code> multiple times in
a text. This vignette will show you how to work with
<code>gloss_factory()</code> so that you only need to type
<code>my_gloss(&quot;my-label&quot;)</code> instead. In addition, this function
performs some validation on your dataframe to avoid undesired
output.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(glossr)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co">#&gt; Setting up the leipzig engine.</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co">#&gt; Attaching package: &#39;dplyr&#39;</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="co">#&gt; The following objects are masked from &#39;package:stats&#39;:</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="co">#&gt;     filter, lag</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co">#&gt; The following objects are masked from &#39;package:base&#39;:</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="co">#&gt;     intersect, setdiff, setequal, union</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">library</span>(stringr)</span></code></pre></div>
<div id="create-a-gloss-factory" class="section level1">
<h1>Create a gloss factory</h1>
<p>The first thing you need to do is assign the return value of
<code>gloss_factory()</code> to a short variable that works for you. I
recommend trying this out in the console, and then calling it in a setup
R chunk that doesn’t print messages or warnings.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>by_label <span class="ot">&lt;-</span> <span class="fu">gloss_factory</span>(glosses)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="co">#&gt; ℹ The following columns will be used for the gloss texts, in the following order:</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co">#&gt; ✔ `source` (not aligned!)</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">#&gt; ✔ `original`, `parsed`, and `language` (aligned columns)</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">#&gt; ✔ `translation` (not aligned!)</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">#&gt; ✔ The `label` column will be used for labels.</span></span></code></pre></div>
<p>By default (unless <code>verbose = FALSE</code>),
<code>gloss_factory()</code> prints a few messages after checking the
dataframe that was provided: it checks whether there are
<code>source</code>, <code>translation</code> and <code>label</code>
columns (“not aligned”, because they are printed as running text) and
which would be the remaining columns with content for the text lines
(“aligned”, because they are aligned to each other word by word). Notice
how here it includes the <code>language</code> column in the group of
aligned lines, which we don’t want, so we would prefer to remove it.</p>
<p>If any of the expected columns (<code>source</code>,
<code>translation</code> or <code>label</code>) are not present, it will
print a warning. These are just warnings: maybe it’s exactly what
<em>you</em> are expecting, and that’s ok.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>by_label <span class="ot">&lt;-</span> glosses <span class="sc">|&gt;</span> </span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span>language, <span class="sc">-</span>translation) <span class="sc">|&gt;</span> </span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="fu">gloss_factory</span>()</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co">#&gt; ℹ The following columns will be used for the gloss texts, in the following order:</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#&gt; ✔ `source` (not aligned!)</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#&gt; ✔ `original` and `parsed` (aligned columns)</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">#&gt; ✖ `translation` (not aligned!)</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt; ✔ The `label` column will be used for labels.</span></span></code></pre></div>
<p>If there are too many text columns, it will also warn you:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>by_label <span class="ot">&lt;-</span> glosses<span class="sc">|&gt;</span> </span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="fu">rename</span>(<span class="at">trans =</span> translation)<span class="sc">|&gt;</span> </span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="fu">gloss_factory</span>()</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">#&gt; ! There are 4 columns that can be printed as text: `original`, `parsed`,</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">#&gt; `trans`, and `language`. Only the first three will be used.</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt; ℹ The following columns will be used for the gloss texts, in the following order:</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co">#&gt; ✔ `source` (not aligned!)</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co">#&gt; ✔ `original`, `parsed`, and `trans` (aligned columns)</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="co">#&gt; ✖ `translation` (not aligned!)</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co">#&gt; ✔ The `label` column will be used for labels.</span></span></code></pre></div>
<p>We can either remove the extra column from the dataframe before
giving it to <code>gloss_factory()</code> or add its name to the
<code>ignore_columns</code> argument. This allows us to use the column
for filtering without <code>gloss_df()</code> finding out of its
existence. Other kinds of modifications, however, would have to be
performed beforehand.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>modified_glosses <span class="ot">&lt;-</span> glosses <span class="sc">|&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">source =</span> <span class="fu">paste0</span>(<span class="st">&quot;(&quot;</span>, source, <span class="st">&quot;)&quot;</span>))</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>by_label <span class="ot">&lt;-</span> modified_glosses <span class="sc">|&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>  <span class="fu">gloss_factory</span>(<span class="at">ignore_columns =</span> <span class="st">&quot;language&quot;</span>)</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">#&gt; ℹ The following columns will be used for the gloss texts, in the following order:</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co">#&gt; ✔ `source` (not aligned!)</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">#&gt; ✔ `original` and `parsed` (aligned columns)</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co">#&gt; ✔ `translation` (not aligned!)</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="co">#&gt; ✔ The `label` column will be used for labels.</span></span></code></pre></div>
<p><code>gloss_factory()</code> is a <a href="https://adv-r.hadley.nz/function-factories.html">function
factory</a>: its output is a function.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">class</span>(by_label)</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co">#&gt; [1] &quot;function&quot;</span></span></code></pre></div>
<p>This means that you call <code>gloss_factory()</code> once at the
beginning, and then your created function as many times as you need.
Here the function is called <code>by_label()</code>, but you can choose
the name that suits you best. As you can see below,
<code>by_label(&quot;heartwarming-jp&quot;)</code> is equivalent to
<code>gloss_df(filter(modified_glosses, label == &quot;heartwarming-jp&quot;))</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">by_label</span>(<span class="st">&quot;heartwarming-jp&quot;</span>)</span></code></pre></div>
<ol class="example" style="list-style-type: decimal">
<li><style>.gloss__line--original {font-style:normal;font-weight:normal} .gloss__word .gloss__line:first-child {font-style:normal;font-weight:normal} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Shindo 2015:660)
</p>
<p>
Kotae-nagara otousan to okaasan wa honobonoto atatakai2 mono ni
tsutsum-areru kimochi ga shi-ta.
</p>
<p>
reply-while father and mother TOP heartwarming warm thing with
surround-PASS feeling NOM do-PST
</p>
<p class="gloss__line--free">
“While replying (to your question), Father and Mother felt like they
were surrounded by something heart warming.”
</p>
</div>
<script>document.addEventListener('DOMContentLoaded', function() {Leipzig({lastLineFree: false}).gloss();});</script></li>
</ol>
</div>
<div id="filter-by-label-or-id" class="section level1">
<h1>Filter by label or id</h1>
<p>By default, the function created by <code>gloss_factory()</code> will
take a label or set of labels and use it for filtering. In principle,
the call below is equivalent to
<code>gloss_df(filter(modified_glosses, label %in% c(&quot;heartwarming-jp&quot;, &quot;languid-jp&quot;, &quot;feel-dutch&quot;)))</code>.
However, unlike <code>filter()</code>, it keeps the requested order of
your items!</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">by_label</span>(<span class="st">&quot;heartwarming-jp&quot;</span>, <span class="st">&quot;languid-jp&quot;</span>, <span class="st">&quot;feel-dutch&quot;</span>)</span></code></pre></div>
<ol start="2" class="example" style="list-style-type: decimal">
<li><style>.gloss__line--original {font-style:normal;font-weight:normal} .gloss__word .gloss__line:first-child {font-style:normal;font-weight:normal} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Shindo 2015:660)
</p>
<p>
Kotae-nagara otousan to okaasan wa honobonoto atatakai2 mono ni
tsutsum-areru kimochi ga shi-ta.
</p>
<p>
reply-while father and mother TOP heartwarming warm thing with
surround-PASS feeling NOM do-PST
</p>
<p class="gloss__line--free">
“While replying (to your question), Father and Mother felt like they
were surrounded by something heart warming.”
</p>
</div></li>
<li><style>.gloss__line--original {font-style:normal;font-weight:normal} .gloss__word .gloss__line:first-child {font-style:normal;font-weight:normal} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Shindo 2015:660)
</p>
<p>
Ainiku sonna shumi wa nai. Tsumetai-none. Kedaru-souna koe da-tta.
</p>
<p>
unfortunately such interest TOP not.exist cold-EMPH languid-seem voice
COP-PST
</p>
<p class="gloss__line--free">
“Unfortunately I never have such an interest. You are so cold. (Her)
voice sounded languid.”
</p>
</div></li>
<li><style>.gloss__line--original {font-style:normal;font-weight:normal} .gloss__word .gloss__line:first-child {font-style:normal;font-weight:normal} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Ross 1996:204)
</p>
<p>
Ik heb het koud
</p>
<p>
1SG have 3SG COLD.A
</p>
<p class="gloss__line--free">
“I am cold; literally: I have it cold.”
</p>
</div></li>
</ol>
<p>You could also set a different column for your ids with the
<code>id_column</code> argument. <code>gloss_factory()</code> will warn
you if the values are not unique (in case you were expecting them
to).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>by_language <span class="ot">&lt;-</span> modified_glosses <span class="sc">|&gt;</span> </span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  <span class="fu">gloss_factory</span>(<span class="at">id_column =</span> <span class="st">&quot;language&quot;</span>, <span class="at">ignore_columns =</span> <span class="st">&quot;language&quot;</span>)</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co">#&gt; ℹ The following columns will be used for the gloss texts, in the following order:</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co">#&gt; ✔ `source` (not aligned!)</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co">#&gt; ✔ `original` and `parsed` (aligned columns)</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co">#&gt; ✔ `translation` (not aligned!)</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co">#&gt; ✔ The `label` column will be used for labels.</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a><span class="co">#&gt; ! The values in `language` are not unique. Only the first match of repeated ids will be returned.</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">by_language</span>(<span class="st">&quot;Icelandic&quot;</span>)</span></code></pre></div>
<ol start="5" class="example" style="list-style-type: decimal">
<li><style>.gloss__line--original {font-style:normal;font-weight:normal} .gloss__word .gloss__line:first-child {font-style:normal;font-weight:normal} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Einarsson 1945:170)
</p>
<p>
Mér er heitt/kalt
</p>
<p>
1SG.DAT COP.1SG.PRS hot/cold.A
</p>
<p class="gloss__line--free">
“I am hot/cold.”
</p>
</div></li>
</ol>
<p>You will also get a warning if one of your requested ids is not in
your dataset.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">by_language</span>(<span class="st">&quot;Japanese&quot;</span>, <span class="st">&quot;Mandarin&quot;</span>)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="co">#&gt; ! The following ids are not present in the dataset:</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co">#&gt; • Mandarin</span></span></code></pre></div>
<ol start="6" class="example" style="list-style-type: decimal">
<li><style>.gloss__line--original {font-style:normal;font-weight:normal} .gloss__word .gloss__line:first-child {font-style:normal;font-weight:normal} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Shindo 2015:660)
</p>
<p>
Kotae-nagara otousan to okaasan wa honobonoto atatakai2 mono ni
tsutsum-areru kimochi ga shi-ta.
</p>
<p>
reply-while father and mother TOP heartwarming warm thing with
surround-PASS feeling NOM do-PST
</p>
<p class="gloss__line--free">
“While replying (to your question), Father and Mother felt like they
were surrounded by something heart warming.”
</p>
</div></li>
</ol>
</div>
<div id="filter-with-other-conditional-statements" class="section level1">
<h1>Filter with other conditional statements</h1>
<p>While filtering by label name might be a common circumstance, you
might want a bit more freedom. It is possible to create a different
function with the <code>use_conditionals</code> argument. In that case,
the new function will take whatever conditionals you want to ask and
send them to <code>dplyr::filter()</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>by_cond <span class="ot">&lt;-</span> modified_glosses <span class="sc">|&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>  <span class="fu">gloss_factory</span>(<span class="at">use_conditionals =</span> <span class="cn">TRUE</span>, <span class="at">ignore_columns =</span> <span class="st">&quot;language&quot;</span>)</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="co">#&gt; ℹ The following columns will be used for the gloss texts, in the following order:</span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="co">#&gt; ✔ `source` (not aligned!)</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="co">#&gt; ✔ `original` and `parsed` (aligned columns)</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="co">#&gt; ✔ `translation` (not aligned!)</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="co">#&gt; ✔ The `label` column will be used for labels.</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="fu">by_cond</span>(<span class="fu">str_ends</span>(label, <span class="st">&quot;jp&quot;</span>))</span></code></pre></div>
<ol start="7" class="example" style="list-style-type: decimal">
<li><style>.gloss__line--original {font-style:normal;font-weight:normal} .gloss__word .gloss__line:first-child {font-style:normal;font-weight:normal} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Shindo 2015:660)
</p>
<p>
Kotae-nagara otousan to okaasan wa honobonoto atatakai2 mono ni
tsutsum-areru kimochi ga shi-ta.
</p>
<p>
reply-while father and mother TOP heartwarming warm thing with
surround-PASS feeling NOM do-PST
</p>
<p class="gloss__line--free">
“While replying (to your question), Father and Mother felt like they
were surrounded by something heart warming.”
</p>
</div></li>
<li><style>.gloss__line--original {font-style:normal;font-weight:normal} .gloss__word .gloss__line:first-child {font-style:normal;font-weight:normal} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Shindo 2015:660)
</p>
<p>
Ainiku sonna shumi wa nai. Tsumetai-none. Kedaru-souna koe da-tta.
</p>
<p>
unfortunately such interest TOP not.exist cold-EMPH languid-seem voice
COP-PST
</p>
<p class="gloss__line--free">
“Unfortunately I never have such an interest. You are so cold. (Her)
voice sounded languid.”
</p>
</div></li>
</ol>
</div>
<div id="many-factories" class="section level1">
<h1>Many factories?</h1>
<p>One of the advantages of a function factory is that you can create a
function tailored to the dataset you’re working with here. You don’t
need to call your dataset constantly and you save in typing.</p>
<p>In addition, you could have multiple factories in one project. Within
a file, you may create a <code>by_label()</code> and a
<code>by_cond()</code> functions to work with label and conditional
filtering, whatever suits you best at any time. Or you could also have a
<code>dutch_gloss()</code> and <code>chinese_gloss()</code>, for
example, each using a different dataset!</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
