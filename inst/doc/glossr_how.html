<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Mariana Montes" />

<meta name="date" content="2022-06-07" />

<title>Using the glossr package</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<style type="text/css">.gloss--glossed:after {clear: left;content: '';display: block;}ul.gloss--glossed,ol.gloss--glossed {padding-left: 0;}ul.gloss--glossed li,ol.gloss--glossed li {list-style-type: none;}.gloss__abbr {font-variant: small-caps;font-variant-numeric: oldstyle-nums;text-transform: lowercase;}.gloss__word {float: left;margin-bottom: 1em;margin-right: 1em;}.gloss__word p {margin: 0;}.gloss--no-space .gloss__word {margin-right: 0;}.gloss--no-space .gloss__word.gloss__word--spacer {margin-right: 1.5em;}.gloss__words:first-child,.gloss--glossed li:first-child {margin-top: 1em;}.gloss--glossed li:last-child {margin-bottom: 1em;}.gloss__line--original {margin-bottom: 1em;}.gloss__line--free,.gloss__line--no-align {clear: left;}.gloss__line--hidden {display: none;}</style>
<script>/*! leipzig.js v0.8.0 | ISC License | github.com/bdchauvette/leipzig.js */
(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define('Leipzig', ['exports', 'module'], factory);
  } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
    factory(exports, module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, mod);
    global.Leipzig = mod.exports;
  }
})(this, function (exports, module) {
  'use strict';

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
  Adds a class to an element
  @private
  @param {Element} el - element to add the class to
  @param {String} className - class name to add
  */
  function addClass(el, className) {
    if (el.classList) {
      el.classList.add(className);
    } else {
      el.className += ' ' + className;
    }
  }

  /**
  Checks if an element has a given class
  @private
  @param {Element} el - element to search for the class
  @param {String} className - class name to search for
  */
  function hasClass(el, className) {
    var test;

    if (el.classList) {
      test = el.classList.contains(className);
    } else {
      var className = new RegExp('(^| )' + className + '( |$)', 'gi');
      test = new RegExp(className).test(el.className);
    }

    return test;
  }

  /**
  Helper function for creating custom events
  @private
  */
  function LeipzigEvent(name, data) {
    var leipzigEvent = undefined;

    if (window.CustomEvent) {
      leipzigEvent = new CustomEvent(name, {
        detail: data,
        bubbles: true,
        cancelable: true
      });
    } else {
      // For Internet Explorer & PhantomJS
      leipzigEvent = document.createEvent('CustomEvent');
      leipzigEvent.initCustomEvent(name, true, true, data);
    }

    return leipzigEvent;
  }

  /**
  Helper function for triggering custom events
  @private
  */
  function triggerEvent(el, name, data) {
    var e = new LeipzigEvent(name, data);
    el.dispatchEvent(e);
  }

  /**
  Helper function for cloning an object
  @private
  */
  function clone(obj) {
    return _extends({}, obj);
  }

  /**
  Default abbreviations used by the auto tagger
  @private
  */
  var abbreviations = {
    1: 'first person',
    2: 'second person',
    3: 'third person',
    A: 'agent-like argument of canonical transitive verb',
    ABL: 'ablative',
    ABS: 'absolutive',
    ACC: 'accusative',
    ADJ: 'adjective',
    ADV: 'adverb(ial)',
    AGR: 'agreement',
    ALL: 'allative',
    ANTIP: 'antipassive',
    APPL: 'applicative',
    ART: 'article',
    AUX: 'auxiliary',
    BEN: 'benefactive',
    CAUS: 'causative',
    CLF: 'classifier',
    COM: 'comitative',
    COMP: 'complementizer',
    COMPL: 'completive',
    COND: 'conditional',
    COP: 'copula',
    CVB: 'converb',
    DAT: 'dative',
    DECL: 'declarative',
    DEF: 'definite',
    DEM: 'demonstrative',
    DET: 'determiner',
    DIST: 'distal',
    DISTR: 'distributive',
    DU: 'dual',
    DUR: 'durative',
    ERG: 'ergative',
    EXCL: 'exclusive',
    F: 'feminine',
    FOC: 'focus',
    FUT: 'future',
    GEN: 'genitive',
    IMP: 'imperative',
    INCL: 'inclusive',
    IND: 'indicative',
    INDF: 'indefinite',
    INF: 'infinitive',
    INS: 'instrumental',
    INTR: 'intransitive',
    IPFV: 'imperfective',
    IRR: 'irrealis',
    LOC: 'locative',
    M: 'masculine',
    N: 'neuter',
    NEG: 'negation / negative',
    NMLZ: 'nominalizer / nominalization',
    NOM: 'nominative',
    OBJ: 'object',
    OBL: 'oblique',
    P: 'patient-like argument of canonical transitive verb',
    PASS: 'passive',
    PFV: 'perfective',
    PL: 'plural',
    POSS: 'possessive',
    PRED: 'predicative',
    PRF: 'perfect',
    PRS: 'present',
    PROG: 'progressive',
    PROH: 'prohibitive',
    PROX: 'proximal / proximate',
    PST: 'past',
    PTCP: 'participle',
    PURP: 'purposive',
    Q: 'question particle / marker',
    QUOT: 'quotative',
    RECP: 'reciprocal',
    REFL: 'reflexive',
    REL: 'relative',
    RES: 'resultative',
    S: 'single argument of canonical intransitive verb',
    SBJ: 'subject',
    SBJV: 'subjunctive',
    SG: 'singular',
    TOP: 'topic',
    TR: 'transitive',
    VOC: 'vocative'
  };

  /**
  Creates a Leipzig.js glossing object
  @constructor
  @param {String|NodeList|Element} selector - determines elements to be glossed
  @param {Object} config - configuration object
  */
  var Leipzig = function Leipzig(selector) {
    var config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    if (!(this instanceof Leipzig)) {
      return new Leipzig(selector, config);
    }

    if (typeof selector !== 'undefined') {
      if (typeof selector === 'string' || selector instanceof NodeList || selector instanceof Element) {
        config.selector = selector;
      } else if (typeof selector === 'object') {
        // if the first argument is an object, let's assume it's actually a
        // configuration object, and not the selector
        config = selector;
      } else {
        throw new Error('Invalid selector');
      }
    }

    this.config(config);
  };

  /**
  Configures the Leipzig instance
  @param {Object} options - the options
  */
  Leipzig.prototype.config = function (options) {
    var config = {
      selector: '[data-gloss]',
      lastLineFree: true,
      firstLineOrig: false,
      spacing: true,
      autoTag: true,
      async: false,
      lexer: /{(.*?)}|([^\s]+)/g,
      events: {
        beforeGloss: 'gloss:beforeGloss',
        afterGloss: 'gloss:afterGloss',
        beforeLex: 'gloss:beforeLex',
        afterLex: 'gloss:afterLex',
        beforeAlign: 'gloss:beforeAlign',
        afterAlign: 'gloss:afterAlign',
        beforeFormat: 'gloss:beforeFormat',
        afterFormat: 'gloss:afterFormat',
        start: 'gloss:start',
        complete: 'gloss:complete'
      },
      classes: {
        glossed: 'gloss--glossed',
        noSpace: 'gloss--no-space',
        words: 'gloss__words',
        word: 'gloss__word',
        spacer: 'gloss__word--spacer',
        abbr: 'gloss__abbr',
        line: 'gloss__line',
        lineNum: 'gloss__line--',
        original: 'gloss__line--original',
        freeTranslation: 'gloss__line--free',
        noAlign: 'gloss__line--no-align',
        hidden: 'gloss__line--hidden'
      },
      abbreviations: abbreviations
    };

    _extends(config, options);

    // selector should be a string, NodeList or an array of Elements.
    // We'll actually select the elements later, to avoid possible differences
    // in the DOM between construction and glossing
    if (typeof config.selector !== 'string' && !(config.selector instanceof NodeList) && !(config.selector instanceof Element)) {
      throw new Error('Invalid selector');
    }

    // construct the lexer RegExp now, so that we don't have to create it each
    // time the lexer runs
    if (!(config.lexer instanceof RegExp)) {
      if (typeof config.lexer === 'string') {
        config.lexer = new RegExp(config.lexer, 'g');
      } else if (config.lexer instanceof Array) {
        var lexer = config.lexer.join('|');
        config.lexer = new RegExp(lexer, 'g');
      } else {
        throw new Error('Invalid lexer');
      }
    }

    _extends(this, config);
  };

  /**
  Adds abbreviations
  @param {Object} abbreviations - the abbreviations to add
  */
  Leipzig.prototype.addAbbreviations = function (abbreviations) {
    if (typeof abbreviations === 'object') {
      _extends(this.abbreviations, abbreviations);
    } else {
      throw new Error('Invalid abbreviations');
    }
  };

  /**
  Sets abbreviations, overriding existing ones
  @param {Object} abbreviations - the abbreviation definitions
  */
  Leipzig.prototype.setAbbreviations = function (abbreviations) {
    if (typeof abbreviations === 'object') {
      this.abbreviations = abbreviations;
    } else {
      throw new Error('Invalid abbreviations');
    }
  };

  /**
  Extracts word tokens from a gloss line
  @private
  @param {Element} line - the phrase to be lexed
  @returns {Array} The tokens
  */
  Leipzig.prototype.lex = function lex(line) {
    var lexer = this.lexer;

    var tokens = line.match(lexer).map(function (token) {
      // remove braces from groups
      var firstChar = token[0];
      var lastChar = token[token.length - 1];

      if (firstChar === '{' && lastChar === '}') {
        var contents = /(?:{)(.*)(?:})/;
        token = contents.exec(token)[1];
      }

      return token;
    });

    return tokens;
  };

  /**
  Add HTML abbreviation markup to a word
  @private
  @param {String} word - the word to be tagged
  @returns {String} html-tagged word
  */
  Leipzig.prototype.tag = function tag(word) {
    var classes = this.classes;
    var abbreviations = this.abbreviations;

    // (\b[0-4])(?=[A-Z]|\b) : Person & Number
    // (N?[A-Z]+\b)          : Morphemes
    var tagger = /(\b[0-4])(?=[A-Z]|\b)|(N?[A-Z]+\b)/g;
    var tags = word.replace(tagger, function (tag) {
      var maybeNegative = tag[0] === 'N' && tag.length > 1;
      var negStem = maybeNegative ? tag.slice(1) : tag;

      var tagged = undefined;
      var definition = undefined;

      if (abbreviations[tag]) {
        definition = abbreviations[tag];
        tagged = '<abbr class="' + classes.abbr + '" title="' + definition + '">' + tag + '</abbr>';
      } else if (maybeNegative && abbreviations[negStem]) {
        definition = abbreviations[negStem];
        tagged = '<abbr class="' + classes.abbr + '" title="non-' + definition + '">' + tag + '</abbr>';
      } else {
        tagged = '<abbr class="' + classes.abbr + '">' + tag + '</abbr>';
      }

      return tagged;
    });

    return tags;
  };

  /**
  Aligns morphemes on different lines
  @private
  @param {Array} lines - Array of strings to be aligned
  @returns {Array} Array of arrays containing aligned words
  */
  Leipzig.prototype.align = function align(lines) {
    var longestLine = lines.reduce(function (a, b) {
      return a.length > b.length ? a : b;
    }, []);

    return longestLine.map(function (_, i) {
      return lines.map(function (line) {
        return typeof line[i] === 'undefined' ? '' : line[i];
      });
    });
  };

  /**
  Creates an Element containing the aligned glosses
  @private
  @param {Array<Array<String>>} lines - lines to be formatted
  @returns {Element} html element containing the glosses
  */
  Leipzig.prototype.format = function format(groups, wrapperType, lineNumStart) {
    var _this = this;

    var tag = this.tag;

    var spacing = this.spacing;
    var autoTag = this.autoTag;
    var classes = this.classes;
    var wrapper = document.createElement(wrapperType);
    var innerHtml = [];

    addClass(wrapper, classes.words);

    groups.forEach(function (group) {
      var groupLines = [];
      var isEmpty = true;

      group.forEach(function (line, lineNumOffset) {
        var lineNum = lineNumStart + lineNumOffset;
        var lineClasses = [classes.line, classes.lineNum + lineNum];

        if (line.length) {
          isEmpty = false;
        }

        if (lineNumOffset > 0 && autoTag) {
          line = _this.tag(line);
        }

        groupLines.push('<p class="' + lineClasses.join(' ') + '">' + line + '</p>');
      });

      var wordClasses = classes.word;
      if (isEmpty && !spacing) {
        wordClasses += ' ' + classes.spacer;
      }

      innerHtml.push('<div class="' + wordClasses + '">', groupLines.join(''), '</div>');
    });

    wrapper.innerHTML = innerHtml.join('');

    return wrapper;
  };

  /**
  Runs the glosser
  */
  Leipzig.prototype.gloss = function gloss(callback) {
    var _this2 = this;

    var selector = this.selector;
    var classes = this.classes;
    var events = this.events;
    var firstLineOrig = this.firstLineOrig;
    var lastLineFree = this.lastLineFree;
    var spacing = this.spacing;
    var async = this.async;

    /** Processes an individual gloss element */
    var processGloss = function processGloss(gloss, callback) {
      if (!(gloss instanceof Element)) {
        var err = new Error('Invalid gloss element');

        if (typeof callback === 'function') {
          callback(err);
        } else {
          throw err;
        }
      }

      var lines = Array.prototype.slice.call(gloss.children);
      var linesToAlign = [];
      var firstRawLine = null;
      var firstRawLineNum = 0;

      triggerEvent(gloss, events.beforeGloss);

      if (firstLineOrig) {
        var firstLine = lines[0];
        addClass(firstLine, classes.original);
      }

      if (lastLineFree) {
        var lastLine = lines[lines.length - 1];
        addClass(lastLine, classes.freeTranslation);
      }

      // process each line in the gloss
      lines.forEach(function (line, lineNum) {
        // don't align lines that are free translations or original,
        // unformatted lines
        var isOrig = hasClass(line, classes.original);
        var isFree = hasClass(line, classes.freeTranslation);
        var shouldSkip = hasClass(line, classes.noAlign);

        var shouldAlign = !isOrig && !isFree && !shouldSkip;

        if (shouldAlign) {
          triggerEvent(line, events.beforeLex, { lineNum: lineNum });
          var tokens = _this2.lex(line.innerHTML);
          triggerEvent(line, events.afterLex, {
            tokens: tokens,
            lineNum: lineNum
          });

          linesToAlign.push(tokens);
          addClass(line, classes.hidden);

          // if this is the first aligned line, mark the location
          // so that the final aligned glosses can be inserted here
          if (!firstRawLine) {
            firstRawLine = line;
            firstRawLineNum = lineNum;
          }
        } else {
          addClass(line, classes.line);
          addClass(line, classes.lineNum + lineNum);
        }
      });

      var lastRawLineNum = firstRawLineNum + (linesToAlign.length - 1);

      triggerEvent(gloss, events.beforeAlign, {
        lines: linesToAlign,
        firstLineNum: firstRawLineNum,
        lastLineNum: lastRawLineNum
      });

      var alignedLines = _this2.align(linesToAlign);

      triggerEvent(gloss, events.afterAlign, {
        lines: alignedLines,
        firstLineNum: firstRawLineNum,
        lastLineNum: lastRawLineNum
      });

      // determine which type of element the aligned glosses should be wrapped in
      var alignedWrapper = undefined;
      if (gloss.tagName === 'UL' || gloss.tagName === 'OL') {
        alignedWrapper = 'li';
      } else {
        alignedWrapper = 'div';
      }

      triggerEvent(gloss, events.beforeFormat, {
        lines: alignedLines,
        firstLineNum: firstRawLineNum,
        lastLineNum: lastRawLineNum
      });

      var formattedLines = _this2.format(alignedLines, alignedWrapper, firstRawLineNum);
      gloss.insertBefore(formattedLines, firstRawLine);

      triggerEvent(formattedLines, events.afterFormat, {
        firstLineNum: firstRawLineNum,
        lastLineNum: lastRawLineNum
      });

      // finish up by adding relevant classes to the main container
      if (!spacing) {
        addClass(gloss, classes.noSpace);
      }

      addClass(gloss, classes.glossed);

      triggerEvent(gloss, events.afterGloss);
    };

    var glossElements = undefined;
    if (selector instanceof NodeList) {
      glossElements = selector;
    } else if (typeof selector === 'string') {
      glossElements = document.querySelectorAll(selector);
    } else if (selector instanceof Element) {
      // create an array so we can loop later on
      glossElements = [selector];
    } else {
      var err = new Error('Invalid selector');

      if (typeof callback === 'function') {
        callback(err);
      } else {
        throw err;
      }
    }

    triggerEvent(document, events.start, { glosses: glossElements });

    // process each gloss
    var glosses = Array.prototype.slice.call(glossElements);

    var _loop = function (i) {
      var gloss = glosses[i];

      if (async) {
        window.setTimeout(function () {
          return processGloss(gloss, callback);
        });
      } else {
        processGloss(gloss, callback);
      }
    };

    for (var i = 0; i < glosses.length; i++) {
      _loop(i);
    }

    window.setTimeout(function () {
      if (typeof callback === 'function') {
        callback(null, glossElements);
      }

      triggerEvent(document, events.complete, { glosses: glossElements });
    });
  };

  module.exports = Leipzig;
});</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Using the glossr package</h1>
<h4 class="author">Mariana Montes</h4>
<h4 class="date">2022-06-07</h4>



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>The {glossr} package offers useful functions to recreate interlinear
glosses in R Markdown texts. The immediate solution for a <span class="math inline">\(LaTeX\)</span> output is to use a specific
library, such as {gb4e} (the one I knew when this package was born) or
{expex} (the one this package uses now). If PDF output is enough for
you, you can still use this package to automatically print them in an
R-chunk, minimizing typos<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, and even generate them automatically from
a dataframe with your examples! But chances are, PDF is not enough for
you, and you would also like a nice rendering (or at least <em>some</em>
rendering) of your interlinear glosses in HTML as well… and why not, MS
Word! This offers some challenges, because you would need to figure out
<em>how</em> to render them to begin with, and neither the way to print
them nor the way to reference them are compatible across output formats.
I took that pain and packaged it so you don’t need to feel it.</p>
<p>You can start using <code>glossr</code> in an R Markdown file by
calling the library and then <code>use_glossr()</code> to activate some
background stuff. Mainly, this function informs all the other functions
whether you are using <span class="math inline">\(LaTeX\)</span>, HTML<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> or
neither, in which case it assumes you have Word output. This vignette
has been run in <a href="https://github.com/montesmariana/glossr/tree/main/inst/examples">all
three formats</a> by changing the output format to
<code>bookdown::pdf_document2</code>, which renders a PDF file;
<code>bookdown::html_document2</code> and
<code>rmdformats::readthedown</code>, which render HTML files; and
<code>officedown::rdocx_document</code>, which renders an MS Word file
<span class="citation">(Xie 2022; Gohel and Ross 2022; Barnier
2022)</span>. As you can see in <code>vignette(&quot;styling&quot;)</code>,
<code>use_glossr()</code> also takes some variables to set up
document-wide styling options for specific parts of your glosses. The
code below sets the name of the source to render in boldface and the
first line of each gloss in italics.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(glossr)</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">use_glossr</span>(<span class="at">styling =</span> <span class="fu">list</span>(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">source =</span> <span class="st">&quot;b&quot;</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">first =</span> <span class="st">&quot;i&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Setting up the `leipzig` engine.</span></span></code></pre></div>
</div>
<div id="basic-usage" class="section level1">
<h1>Basic usage</h1>
<p>When you want to include an example, create a gloss with
<code>as_gloss()</code> and call it inside a normal chunk. There are
currently four named, optional arguments that will be treated
specially:</p>
<ul>
<li><p><code>label</code> will be interpreted as the label for
cross-references;</p></li>
<li><p><code>source</code> will be interpreted as text for a non-aligned
first line, e.g. a reference to the source of your example;</p></li>
<li><p><code>translation</code> will be interpreted as text for a free
translation;</p></li>
<li><p><code>trans_glosses</code> indicates what character should
surround the translation, by default <code>&quot;</code>. (See
<code>vignette(&quot;styling&quot;)</code>.)</p></li>
</ul>
<p>All other values will be interpreted as lines to be aligned and
reproduced in the order given, but only up to 3 lines are allowed.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>my_gloss <span class="ot">&lt;-</span> <span class="fu">as_gloss</span>(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;她 哇的一聲 大 哭起來，&quot;</span>,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;tā wā=de-yì-shēng dà kū-qǐlái,&quot;</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;TSG waa.IDEO-LINK-one-sound big cry-inch&quot;</span>,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">translation =</span> <span class="st">&quot;Waaaaa, she began to wail.&quot;</span>,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">label =</span> <span class="st">&quot;my-label&quot;</span>,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">source =</span> <span class="st">&quot;ASBC (nº 100622)&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>my_gloss</span></code></pre></div>
<ol class="example" style="list-style-type: decimal">
<li><style>.gloss__line--original {font-weight: bold;} .gloss__word .gloss__line:first-child {font-style:italic;} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
ASBC (nº 100622)
</p>
<p>
她 哇的一聲 大 哭起來，
</p>
<p>
tā wā=de-yì-shēng dà kū-qǐlái,
</p>
<p>
TSG waa.IDEO-LINK-one-sound big cry-inch
</p>
<p class="gloss__line--free">
“Waaaaa, she began to wail.”
</p>
</div>
<script>document.addEventListener('DOMContentLoaded', function() {Leipzig({lastLineFree: false}).gloss();});</script></li>
</ol>
<p>The label given to <code>as_gloss()</code> allows you to
cross-reference the example: in PDF this looks like
<code>example (\@ref(my-label))</code>, whereas in HTML and Word you
would use <code>example (@my-label)</code>. What should YOU do?
<code>gloss()</code> can be used inline to generate a reference for
either PDF or HTML, depending on the output of your file: (1) in this
case.</p>
<p>If you have many examples, you might want to keep them in their own
file, if you don’t have them like that already. <code>glossr</code>
offers a small dataset for testing, called
<code>data(glosses)</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(magrittr)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr) <span class="co"># for select() and filter()</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(glosses)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>glosses <span class="ot">&lt;-</span> glosses <span class="sc">%&gt;%</span> </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(original, parsed, translation, label, source) <span class="sc">%&gt;%</span> </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">source =</span> <span class="fu">paste0</span>(<span class="st">&quot;(&quot;</span>, source, <span class="st">&quot;)&quot;</span>))</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>glosses</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; # A tibble: 5 × 5</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   original                                       parsed translation label source</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;                                          &lt;chr&gt;  &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; </span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1 Mér er heitt/kalt                              &quot;\\te… I am hot/c… feel… (Eina…</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2 Hace calor/frío                                &quot;make… It is hot/… amb-… (Pust…</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3 Ik heb het koud                                &quot;\\te… I am cold;… feel… (Ross…</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4 Kotae-nagara otousan to okaasan wa honobonoto… &quot;repl… While repl… hear… (Shin…</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5 Ainiku sonna shumi wa nai. Tsumetai-none. Ked… &quot;unfo… Unfortunat… lang… (Shin…</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>glosses<span class="sc">$</span>label</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;feel-icelandic&quot;  &quot;amb-spanish&quot;     &quot;feel-dutch&quot;      &quot;heartwarming-jp&quot;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [5] &quot;languid-jp&quot;</span></span></code></pre></div>
<p>Assuming you have them in a table with columns matching the arguments
of <code>as_gloss()</code>, you can give it to <code>gloss_df()</code>
directly and it will do the job. That is: columns named “translation”,
“source”, “label” and “trans_glosses” will be interpreted as those
arguments, and all the others will be read as lines to align regardless
of their column names. This table has more columns than we need, so we
will only select the right ones and print the glosses of the first three
rows. Note that the values in the “label” column will be used as labels:
<code>`r gloss(&quot;feel-icelandic&quot;)`</code> will return (2).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gloss_df</span>(<span class="fu">head</span>(glosses, <span class="dv">3</span>))</span></code></pre></div>
<ol start="2" class="example" style="list-style-type: decimal">
<li><style>.gloss__line--original {font-weight: bold;} .gloss__word .gloss__line:first-child {font-style:italic;} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Einarsson 1945:170)
</p>
<p>
Mér er heitt/kalt
</p>
<p>
1SG.DAT COP.1SG.PRS hot/cold.A
</p>
<p class="gloss__line--free">
“I am hot/cold.”
</p>
</div></li>
<li><style>.gloss__line--original {font-weight: bold;} .gloss__word .gloss__line:first-child {font-style:italic;} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Pustet 2015:908)
</p>
<p>
Hace calor/frío
</p>
<p>
make.3SG.PRS heat/cold..N.A
</p>
<p class="gloss__line--free">
“It is hot/cold; literally: it makes heat/cold.”
</p>
</div></li>
<li><style>.gloss__line--original {font-weight: bold;} .gloss__word .gloss__line:first-child {font-style:italic;} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Ross 1996:204)
</p>
<p>
Ik heb het koud
</p>
<p>
1SG have 3SG COLD.A
</p>
<p class="gloss__line--free">
“I am cold; literally: I have it cold.”
</p>
</div></li>
</ol>
</div>
<div id="pdf-only-features" class="section level1">
<h1>PDF-only features</h1>
<p>This package also offers a few extensions when working on PDF output.
On the one hand, <code>gloss_list()</code> allows you to nest a list of
glosses and have both a reference for the list and for each individual
item. <strong>This will not work in HTML or Word</strong>, which will
just keep the numbering on the top level. But on PDF, given the function
on some examples from <span class="citation">Shindo (2015)</span>, we
can use <code>`r gloss(&quot;jp&quot;)`</code> to reference (<span class="citation">(<strong>jp?</strong>)</span>), or
<code>`r gloss(&quot;heartwarming-jp&quot;)`</code> and
<code>`r gloss(&quot;languid-jp&quot;)`</code> to reference (5) and (6).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span>(glosses, <span class="fu">endsWith</span>(label, <span class="st">&quot;jp&quot;</span>)) <span class="sc">%&gt;%</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gloss_df</span>() <span class="sc">%&gt;%</span> </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gloss_list</span>(<span class="at">listlabel =</span> <span class="st">&quot;jp&quot;</span>)</span></code></pre></div>
<ol start="5" class="example" style="list-style-type: decimal">
<li><style>.gloss__line--original {font-weight: bold;} .gloss__word .gloss__line:first-child {font-style:italic;} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Shindo 2015:660)
</p>
<p>
Kotae-nagara otousan to okaasan wa honobonoto atatakai2 mono ni
tsutsum-areru kimochi ga shi-ta.
</p>
<p>
reply-while father and mother TOP heartwarming warm thing with
surround-PASS feeling NOM do-PST
</p>
<p class="gloss__line--free">
“While replying (to your question), Father and Mother felt like they
were surrounded by something heart warming.”
</p>
</div></li>
<li><style>.gloss__line--original {font-weight: bold;} .gloss__word .gloss__line:first-child {font-style:italic;} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
(Shindo 2015:660)
</p>
<p>
Ainiku sonna shumi wa nai. Tsumetai-none. Kedaru-souna koe da-tta.
</p>
<p>
unfortunately such interest TOP not.exist cold-EMPH languid-seem voice
COP-PST
</p>
<p class="gloss__line--free">
“Unfortunately I never have such an interest. You are so cold. (Her)
voice sounded languid.”
</p>
</div></li>
</ol>
<p>Finally, it might be the case that you want to apply <span class="math inline">\(LaTeX\)</span> formatting to a long string of
elements for your first lines of glosses, e.g. set half of your example
in italics. In order to facilitate applying the same formatting to each
individual element, this package offers you
<code>gloss_format_words()</code>, which you can implement to the
strings given to <code>as_gloss()</code>.</p>
<p>Internally, <code>glossr</code> will try to parse <span class="math inline">\(LaTeX\)</span> formatting into HTML but currently
it doesn’t parse it to Word or read HTML/markdown tags. (But see
<code>vignette(&quot;styling&quot;)</code>.)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gloss_format_words</span>(<span class="st">&quot;A long piece of text&quot;</span>, <span class="st">&quot;textit&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;\\textit{A} \\textit{long} \\textit{piece} \\textit{of} \\textit{text}&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>my_gloss <span class="ot">&lt;-</span> <span class="fu">as_gloss</span>(</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">original =</span> <span class="fu">gloss_format_words</span>(<span class="st">&quot;Hace calor/frío&quot;</span>, <span class="st">&quot;textbf&quot;</span>),</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">parsed =</span> <span class="st">&quot;make.3SG.PRS heat/cold.N.A&quot;</span>,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">translation =</span> <span class="st">&quot;&#39;It is hot/cold&#39;&quot;</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">label =</span> <span class="st">&quot;formatted&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>my_gloss</span></code></pre></div>
<ol start="7" class="example" style="list-style-type: decimal">
<li><style>.gloss__line--original {font-weight: bold;} .gloss__word .gloss__line:first-child {font-style:italic;} .gloss__word .gloss__line--2 {font-style:normal;font-weight:normal} .gloss__word .gloss__line--3 {font-style:normal;font-weight:normal} .gloss__line--free {font-style:normal;font-weight:normal}</style>
<div data-gloss>
<p class="gloss__line--original">
 
</p>
<p>
<strong>Hace</strong> <strong>calor/frío</strong>
</p>
<p>
make.3SG.PRS heat/cold.N.A
</p>
<p class="gloss__line--free">
“‘It is hot/cold’”
</p>
</div></li>
</ol>
</div>
<div id="about-the-formats" class="section level1">
<h1>About the formats</h1>
<p>The Latex output writes your glosses with the format required by the
<a href="https://ctan.org/pkg/expex?lang=en">{expex} package</a>. The
default HTML rendering uses <a href="https://github.com/bdchauvette/leipzig.js/">leipzig.js 0.8.0</a>
(and, of course, {htmltools} <span class="citation">(Cheng et al.
2021)</span> to read it with R). The Word output is an invisible table
generated with {flextable} <span class="citation">(Gohel 2022)</span>.
Note that if the translation is very long it could exceed the margins of
the file in Word (as is the case of example (5)), and at least for the
time being you need to fix it manually by selecting the translation and
reducing the width of its cell.</p>
<p>If you are familiar with these tools and would like to suggests
expansions or contribute to the package, go ahead, I would love to hear
from you!</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-R-rmdformats" class="csl-entry">
Barnier, Julien. 2022. <em>Rmdformats: HTML Output Formats and Templates
for ’Rmarkdown’ Documents</em>. <a href="https://CRAN.R-project.org/package=rmdformats">https://CRAN.R-project.org/package=rmdformats</a>.
</div>
<div id="ref-R-htmltools" class="csl-entry">
Cheng, Joe, Carson Sievert, Barret Schloerke, Winston Chang, Yihui Xie,
and Jeff Allen. 2021. <em>Htmltools: Tools for HTML</em>. <a href="https://github.com/rstudio/htmltools">https://github.com/rstudio/htmltools</a>.
</div>
<div id="ref-R-flextable" class="csl-entry">
Gohel, David. 2022. <em>Flextable: Functions for Tabular Reporting</em>.
<a href="https://CRAN.R-project.org/package=flextable">https://CRAN.R-project.org/package=flextable</a>.
</div>
<div id="ref-R-officedown" class="csl-entry">
Gohel, David, and Noam Ross. 2022. <em>Officedown: Enhanced r Markdown
Format for Word and PowerPoint</em>. <a href="https://CRAN.R-project.org/package=officedown">https://CRAN.R-project.org/package=officedown</a>.
</div>
<div id="ref-shindo_2015" class="csl-entry">
Shindo, Mika. 2015. <span>“Subdomains of Temperature Concepts in
<span>Japanese</span>.”</span> In <em>The <span>Linguistics</span> of
<span>Temperature</span></em>, edited by Maria Koptjevskaja-Tamm,
639–65. Typological <span>Studies</span> in <span>Language</span>.
<span>Amsterdam</span>: <span>John Benjamins Publishing Company</span>.
</div>
<div id="ref-R-bookdown" class="csl-entry">
Xie, Yihui. 2022. <em>Bookdown: Authoring Books and Technical Documents
with r Markdown</em>. <a href="https://CRAN.R-project.org/package=bookdown">https://CRAN.R-project.org/package=bookdown</a>.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>Most of my code is designed to avoid typos. Let’s just
say that this package would have taken a few hours less if I didn’t
constantly write <em>leizpig</em> instead of <em>leipzig</em>.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>You can also choose between the default HTML
implementation, with <a href="https://github.com/bdchauvette/leipzig.js/">leipzig.js</a>, or a
“legacy” implementation with simple tooltips and up to two glossing
lines; do so by running <code>use_glossr(&quot;tooltip&quot;)</code>.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>Note that if you use Chinese characters you will need to
add some <span class="math inline">\(LaTeX\)</span> packages (namely
{fontspec} and {xeCJK}). You can do that either by adding them to <a href="https://bookdown.org/yihui/rmarkdown-cookbook/latex-preamble.html">the
<code>header-includes</code> section</a> or <a href="https://bookdown.org/yihui/rmarkdown-cookbook/latex-extra.html">to
the <code>extra_dependencies</code> list</a> inside the
<code>pdf_document</code> output section in your YAML. Thanks to Thomas
Van Hoey for offering me the example and pointing this out.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
